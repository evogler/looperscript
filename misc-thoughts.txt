FUNCTION SCENARIOS:
(repeatedly 6 #(rand (3 4 5)))
-repeatedly called once; rand called 6 times total

(repeat 6 (rand (3 4 5)))
-rand called once; repeat called once.

#(repeatedly 6 #(rand (3 4 5)))
-repeatedly called each time; rand called 6 times within each repeatedly

#(repeat 6 #(rand (3 4 5)))
-maybe: rand called once within each repeat?
-maybe: repeat returns uncalled rand function?

#(repeat 6 (rand (3 4 5)))
-maybe: rand fixed after very first call?
-maybe: everything within #() called every time? (more clojure-esque)

If, ala the latter options in the last two examples, anything anywhere within a #() is re-evaluated every time, then how to specifiy that something is to be evaluated only once ever?
-#(repeat 6 !(rand (3 4 5))) perhaps?
It seems like it has to be a character added before the parenthesis, to be symmetrical
with #().
-Alternately, using let: (let [x (rand (3 4 5))] #(repeat 6 x))?

Q: Do you ever need more than 3 levels?
-#(repeatedly 3
              #(repeatedly 3
                           #(repeatedly 3 (rand [3 4 5]))))
I think that works fine. But what about:
-#(repeatedly !(rand (1 2 #(rand 3 4))) #(rand (4 5 6))) ?
Should the inner #(rand 3 4) be dethunked?
No, because (rand 3 4) withouth the # would work fine.

Does it matter if there's an inner ! ?
-#(repeatedly !(rand (1 2 !(rand 3 4))) #(rand (4 5 6))) ?

***************************************************************************

MULTI-ASPECTS:
Sooo..... here's my first thought about the basic scenario:
Instead of   time 3 3 2  sound 0 7 12
we'd have    time&sound 3 0  3 7  2 12
or           sound & time 0 3  7 3  12 2
or           sound, time 0,3 7,3 12,2
or           [sound time] [0 3] [7 3] [12 2]
or           sound & time {0 3} {7 3} {12 2}
or           sound & time 0 3, 7 3, 12 2
or (lol)     sound & time {:sound 0 :time 3} {:sound 7 :time 3} {:sound 12 :time 2}

Maybe it's as simple as declaring every other number coming out will be sound or time?
(And commas are used just for readability?) In this trivial case, that works fine.
The real issue is, I want to be able to synchronize multiple aspects with the same
function. I.e., choose each note randomly from ten fully formed notes.
Or from several fully formed phrases!!
Something like: sound&time #(rand [[0 3, 7 3, 12 2] [-1 1, 0 1, -6 1]])
Gosh, does that last bit actually make sense?
rand chooses one of the vectors, and that vector gets divied up by sound&time

What if I wanted to generate the phrases programatically?
(repeatedly 4 #(repeatedly (rand-int 3 7) #([(rand-int -12 12) (rand [1 2 3 4])])))

Actually, I think something like that might work! The tricky part would just be back to
the vectors and functions situation. (Oy, no escaping that stuff).

Would it matter if you wound up feeding the following into rand?:
[[[0 3] [7 3] [12 2]] [[-1 1] [0 1] [-6 1]]]
So that rand might choose [[-1 1] [0 1] [-6 1]], with each note in vectors,
instead of just [-1 1 0 1 -6 1]?
In theory no, right? If the iterator gets the vectory one, it'll just parse through it, same
as anything else.

At this point, I could just add other options vector processing (interleave and/or zip,
maybe a 1 degree flatten) if needed.
Which would allow that last function be written maybe as:
(repeatedly 3 #(interleave (repeatedly 4 #(rand-int -12 12)) (repeatedly 4 #(rand [1 2 3 4]))))

(Except that the phrase-length would have to get refered to more than once, so we're back
to that issue. But otherwise, it works fine...)
(Okay, just to satisfy myself, if I did introduce "let", it would look like this:)
#(let [phrase-len (rand-int 3 7)]
   (interleave (repeatedly phrase-len #(rand-int -12 12))
               (repeteadly phrase-len #(rand [1 2 34 ]))))
Gosh, am I going to have to introduce closures then? I guess there'll just have to be a map
of symbols and values that traverses its way into the tree. Well, guess I'll have to
give it a shot soon.

Btw, would I have wanted a vector function earlier?
(repeatedly 4
  #(repeatedly (rand-int 3 7)
    #(vector (rand-int -12 12) (rand [1 2 3 4]))))

***************************************************************************

NESTED RHYTHMS:

I know I can come up with at least something for this. I'd like the syntax to be
as good as possible. Here are some questions:
-Could all the over functions be contained within a single time function (modifier-style)?
 That way, when we get around to time sub-aspects arbitrary aspects, you won't need to have
 multiple lists for every...
-Does it make sense to try to offer intermittent overs? E.g., do an over for 4 bars,
 then back to normal for 2... I don't want to do what I did in the old looper, just
 specificy some larger number of bars and grind through all of them.
 In some sense, this gets to the question of how to approach going beyond single
 loops. In the above example, would you want to return to the 4 bar over with the phase
 you were at when you left? If so, are they almost just separate sections?

Maybe over with multiple arities? (over [1 2 3] [1 1 2 1 2]) returns the complete vector,
 whereas (over [1 2 3]) returns a modifier?
There is the drawback that you need an extra set of brackets if you want multiple layers.
Maybe just two different functions? (over [1 2 3] [.5 .5 1]) acts as a modifier,
 (over2 [1 2 3] [.5 .5 1]) returns the vector?
I think that's simple enough.
So obviously the "over2" function is simple. The question is how does the modifier
work? Do I accept the mild ugliness of tracking the cumulative value of inputs and
returning the delta of outpus, only the have the cumulative time value recalculated?
Maybe the question comes down to whether solving the problem more elegantly would
lead to anything reusable.
Suppose I made a kind of modifier that gets post-accumulation values. Would I use
that for anything else?
Firstly, I'm pretty sure it would only apply to times. I suppose it could be relevant
to other aspects' time sub-aspects.
I think for my first draft, I'm going to write the over modifier using the ugly
method, since it's self-contained. I think it'll be easy to change if I see a
better way when I add time sub-aspects.
... Holy cow, that was easy! Somehow my intuition was that it should be tougher
than this. But I guess rhythms-interp is already doing the heavy lifting...

Well, okay, one issue is that time modifiers don't get passed into the over
modifier. So if I say 1/2 (over [3 3 4 2 4])

Okay, maybe a bigger problem (which I've already been having, actually):
Apparently no operations work within a vector? Not even 4v5, let alone the tuplet
modifier.

I can get around the 4v5 issue with a flatten. Is there a more elegant solution?
Maybe a way that functions can indicate that they're taking a rhythm as parameter,
so the parameter can get transformed into its final form.

Ohhh, also, a more elaborate version of over might require a more first-class identity
for the other layers. If I wanted to have functions involved in the under layers.
Like time 2 1 1 time-under #(rand [8v8] [10v8]).
Ya, that's gotta still be on the to-do list.

The next step is probably still to think about the format for expressing the
different time layers, which means thinking in general about how to express
multiple streams that combine to yield one aspect.

***************************************************************************

REAL-TIME RELOADING, BACKGROUND PARSER, ETC:

Steps involved in this process:
-Parsing current text
-Knowing if text has changed anyway
-Crunching through queued loop to be keeping up with current time position
-Making swap to queued version of loop.
-Perhaps a bit down the line: assessing whether which elements can be calculated
 directly, which can be crunched through in a reasonable amount of time, and
 which need to simply be started at the current time.

A simple model would be:
-PLAY button runs parser if necessary, then starts playback at 0.
-UPDATE button runs parser. If not playing, queues loop; if playing, replaces old loop
 with new loop once new loop has been crunched up to current time.

Another degree of sophistication would be:
-Detect a certain amount of idle time (a few seconds?), and then try running parser
 in background.
-Diff changes that have been made since last parse and only re-parse those.
-When catching up to current time, when possible, calculate cycle length, to avoid
 having to crunch every repetition.

So the first phase will be to implement the UPDATE button. When pressed, it parses the
text, and if there are no errors, if crunches through the resulting tree until
it is ahead of the current time. I guess it tries to get a few seconds ahead of the
current time, and stores a queue of the advanced notes it has calculated.
When it is ready, the next time a batch of notes is scheduled, the notes from
the new loop are used.

***************************************************************************

MULTI-ASPECTS

First off, maybe I should differentiate the names for a list of numbers versus
an aspect. They've been the same thing up to this point, but if I have multiple
lists cycling that combine to create one aspect, they're not. I guess I can call
them lists vs. aspects. Possibly cycles vs aspects. List-cycles? Items?
Sub-aspects? Aspect-sub-cycles? (That's the most specific and least sayable).
I sort of don't want to call them cycles, since that's already a function.

Well, so for each ... "list" ..., we have to name it, and we have to express how it
works with other lists to create an aspect.
First off, what possiblities are there for a list's function?
-basic list. Essentially what all currently do now. Could be seen as result of
 addition or multiplication of only one number.
-additive. Potentially related to previous.
-multiplicative. Also potentially related to previous.
-limiting. E.g. maximum value, minimum value, etc.
-overriding. Perhaps I want every fifth note simply overridden by something else?
-running through whichever modifier you please? (This would be a way to apply
 modifiers to aspects that are otherwise specified in multi-aspects.
-fn. Just calculating whatever the heck you want in any function, referring to
 other aspects.
-non-cumulative (for time). The way time+ currently functions (changing the start-time
 only of the current note, without affecting subsequent start-times). This should only
 be an issue for time, time being the only cumulative aspect.
 (Perhaps just go with time and time+ as separate aspects

Maybe +, *, etc are modes set within an aspect, and list titles don't need to specify?

Maybe each list is referrable by an equation? E.g. (* (+ time:1 time:2) time:3)
(For God's sake, is the result of that a new cycle? And does the equation live in
its own cycle? As weird as it would be to cycle through different equations, I guess
I don't see why not...)

So the original idea was to have an order to each list, and an identity:
time 3 3 4 2 4
time\2:* 1 1 1 1.5
time\3:+ 0 0 -.5

but now I'm imagining something like
time\1 3 3 4 2 4
time\2 1 1 1 1.5
time\3 0 0 -.5
time #(+ time\3 (* time\1 time\2))

The former is a little simpler to understand (I think). The latter seems to be more
flexible.

Let's just see what one or two more options looks like:

time 3 3 4 2 4
time\2 (*-mode) 1 1 1 1.5
time\3 (+-mode) 0 0 -.5

time #(+ !(cycle [0 0 -.5]) (* !(cycle [1 1 1 1.5]) !(cycle [3 3 4 2 4])))

The last one could certainly be implemented with the least structural tinkering,
but it also seems to open up the fewest possiblities. Assuming that variables are going
to have to be included eventually, this seems like as good as any a time to start.
Also, just off the top of my head, that makes it tougher to mix and match multi-aspect
groupings. Like, what if I wanted:

time\1 & sound 3 k, 3 k, 4 s, 2 k, 4 s
time #(+ time\1 (cycle [0 0 .5]))

or something? Yes, being able to create arbitrary cycles and then combine them as I
specify seems to be the better way.
(Not that there's anything wrong with also making the single-cycle approach possible).

So I guess that leads to a question of how to make values addressable from elsewhere
in the loop. I know I've been leaning towards things dataflow/spreadsheet-like. It would
be simpler to insist that loops only refer to loops that are earlier in the spec, so
that an order of calculation will be obvious. Going with the loose style I've been
leaning towards, I think it would be neat if a loop could actually refer to anything else
that could possibly have a value. That would entail dealing with dataflow stuff like
circular references, but it would open a lot of possibilities. In fact, thinking about
it right now, it really does appeal to me. Instead of tying a given bit of musical
information to a specific place within a specific aspect of a specific part, why
not let the information be its own independent entity, which can be referenced by any
part. I think that fits in a lot better with my musical concept of working abstractly
with material.

So, anything can reference anything else? I can imagine everything is a cycle, and
has a value at a given moment. I suppose the "moment" is the nth item in the cycle.
At a certain moment, every cycle of every aspect of every part is at the 283rd position,
modulo something. Except that those moments vary from part to part. Part 1 could be
at it's 65th note, and part 2 at its 1091st.

So does that mean it's more complicated to refer to cycles outside a given part? Within
a part, time\1 + time\2 + time\3 will be simple to phase. Each will be iterated at
the same time, so the looper will just grab the next value of each one.

But suppose you wanted to define a melody outside of a specific part, and then refer
to it from within multiple parts? The melody (or any cycle) wouldn't have an inherent
phase, unless there were a time aspect associated with it. Actually, it could be conceivable
to create independent loops always with an explicitly defined time component.
At the least, it would be a nice option.
But otherwise, what would it mean if you had

def my-mel 4 2 0 2 4 4 4
part one sound my-mel time 2
part two sound my-mel time 3
?

As far as I can guess, it would mean, iterate through the values of my-mel as needed.

I guess that's two categories of floating data then? Proper cycles with time components,
and simple vectors to be used anywhere?

(In the previous example, I could have added a time component (which I haven't actually
decided how to specify yet))

def my-mel 4 2 0 2 4 4 4
my-mel\time (x 1 6) 2

So in that case, when parts one & two refer to my-mel, do they just automatically
get its current value? Do they specify whether they're taking the current value or
the next increment value? What if I want to specify to pitch information and then apply
multiple time components to it? I guess that would be easier to answer if I had the
specification for time components set in general.
Well, shoot, here I am why not think about that:

part one
sound 4 2 0 2 4 4 4
sound\time 1x6 2
time 1.5

I think that's clear enough? Does it work as an abstraction?
sound ...
sound\time ...
volume ...
volume\time ...
I think it's clear enough.

Immediately I wonder, what if you nested it?
sound ...
sound\time ...
sound\time\time ...
When you're incrementing the sound clock, instead of iterating through sound\time
directly, you check when sound\time\time tells you to move to the next item of sound\time,
and take the appropriate time interval thusly.
(Wow, that will surely confuse anyone who's left at this point. Ha.)

It actually seems to make perfect sense. For any cycle, just check if it has a \time
component. I think that makes sense.

So if I wanted to reference a floating cycle that had a time component specified, but
didn't want to use the time component (which is hard to understand the reason for),
would I say
  part one sound \my-mel sound\time nil
or something?
I guess you'd need a code for clearing it?
Oh, maybe just
  part one sound \my-mel sound\time \one\time
? Just override the time component with the overall part's component? That might work
although it might not be pretty.

So as I'm writing this, I noticed that I'm sort of congealing around a tree structure
concept for organizing and referring to everything.
  \part\aspect\sub-aspect (e.g. \click\sound\time)
It seems clear enough, and kind of fits with my concept of a directory tree struture.
Of course, the other option would be dots.
  click.sound.time
Somehow I find that less distinctive, and a bit more confusing, since it's in contrast
with the S-expression function style.
Here's the whole thing as if "cd"ing through a directory structure

\bass
time 3 3 2
sound 0 7 12
vol 1 .5
\clave
time 3 3 4 2 4
sound #(rand [d h])
sound\time 16

Well, I tweaked this a few times. I couldn't stand to see so many backslashes.

So a question is: how do I differentiate defining things from refering to them?
Is \bass\sound\time an indication that I'm about to define that cycle, or is it a reference
to the cycle?

part click time 1 sound h
volume 1 .5
volume\time 4

part bass
sound 0 2 4
sound\time 4
time 1.5

...volume \click\volume
...volume click\volume
...volume #(- 1 \click\volume)
...volume \click\volume volume\time nil
...volume (get \click\volume)
...volume (copy-straight \click\volume)
...volume (copy-with-sub-aspects \click\volume)

These last few would be a new kind of function. Data reference functions or something.

...volume (get \click\volume) .5 .5 1

What the heck happens there? I guess it's clear enough if \click\volume has its own
time sub-aspect, just check wherever it's at right now.
I guess even if it doesn't, you can still view it that way. Just check what its value
is right now. (In cases where the referencing note and the referenced note are in sync,
you'd want to be sure the referenced one was updated first).

...volume #(rand [\click\volume [1 1 0]])

This seems like it should return the [1 .5] defined at click\volume. No, wait, it should
return the current value of click\volume via click\volume\time. Well, I guess you might
want either of those.

So you could be refering to
-the keyword declaration of a cycle,
-to its elsewhere definition in full
-"   "       "        "      in full, including its sub-aspect(s)
-"   "       "        "      at a given instant.

I guess it's clear enough that you don't start with a backslash when you're defining
something. So how do you differentiate referencing another part in full, (with or without
sub-aspects?), vs. at the current point? (Holy crap, or at some other specific point? Jesus...)
  (current \click\volume)
  (full \click\volume)
I suppose?
  \click\volume\current
  \click\volume\full
Would that mean don't have sub-aspects with those names? I'm not sure if that's where
sub-aspects will be put. I guess there could be variables also. Anyway, if you're involved
enough to be referencing sub-aspects, you're probably involved enough to be told
not to use certain keywords for names.

part clave sound h time 3 3 4 2 4

part divider sound d
time (over \clave\time) .5

part divider2 (default \divider)
rate 2

;;;;;;;;;;

def note 5 10 3 8 1 7 0
note\time 4 4 4 4 4 4 8  ; note & note\time

part mel sound @note
time 1 1 1.5 1.5

... So I'm messing with changing the basic post-transform structure to be a proper map,
instead of a vector of maps with :name properties. I think this is probably more
appropriate. It will mean parts can't have the same name, but that's probably okay.
In a sense, if one is ever trying to make loops with the same name, one is probably
copying and pasting, which means some functionality is lacking. Perhaps I could include
_ as an "untitled" name, which could have an auto-generated name internally. Or just
throw an error if you try to reference a name that applies to more than one part.

So the question is around dataflow and order of evaluation. I think I just have to
try Javelin or another dataflow library, to get a sense for how it's done, even if
I'm going to write my own. I guess I could also just try, for the hell of it.


***************************************************************************

TRIGGERS

[random thought: If triggers communicate through some kind of bus system, maybe there's
also a shared system for "motives", which a part can transform a motive and declare
the resulting transformation on. I guess I've already been thinking about declaring
disembodied fragments of information, but this would be more dynamic. No reason you
couldn't also declare information in the file to go into this system, I guess.
Also, you might as well be able to include transforming functions in the shared
thing. Oh, jeez. This just keeps getting more complicated.]

So, the (initial) idea of triggers is that one process can pause or repeat until another one
signals that it's finished. The original example is if you want to assign drum sounds
to differentiate rhythmic ideas, but don't know how many notes will be in each rhythmic
idea.
While I can see how to do this with multi-aspects already. I think triggers would express
the concept more cleanly.

time #(in 4 (x (rand-int 3 7) 1)) (trig tr)
sound (hold-unless-trigger tr (cycle [d k h]))

time #(v 4 (rand-int 3 7)) tr!
sound (cycle [d k h]) tr?

vs
time & sound #(interleave (v 4 (rand-int 3 7)) (repeat !(cycle [d k h])))

Actually, I'm not sure if the (repeat !(cycle)) part in the last example would currently
work. I'm pretty sure it could be made to work. But I'd still like to be able to write
the trigger version.

Anyway... So do I know what triggers should look like?
For the simple case of one aspects of a part triggering another aspect of said part,
I think I get it. You can intersperse code to send triggers amongst anything else.
  time 5v4 (send-trig tr) 7v4 (send-trig tr)
When the iterator encounters a "send-trig" message instead of a number, it registers
the trigger somewhere and immediately moves on until it finds a number or whatever it
was looking for.
  sound r (until-trig tr [h])

Actually, I could probably write both of those just as functions. send-trig could just
return nil.

Oh, here's a question: how long does a trigger last? Or if it's instantaneous, do you
have a dataflow-type order issue? In this case:
  sound r (until-trig tr [h])
  time 5v4 (send-trig tr) 7v4 (send-trig tr)
how would you keep them in sync? Check each iterator for triggers first? Put a hold on the
awaiting one to see if something else in that beat sends the trigger? I guess these
things are possible, but I still feel like it might be well handled by dataflow.

***************************************************************************

DECLARATIONS

I'm going to try to just implement a simple command where I can run one time stuff.
Initially I think I'll just make it a place to run functions only once at the beginning,
with the possibliity of declaring variables magically from within functions.

Although... what happens if I try to update a file in real time but don't restart it?
Well, I think I just have to re-run those functions, and see what I get. If they're
not stochastic, they'll return the same data.

So it's just going to be

bpm 234  ; of course this theoretically would go in the init area...
init
(def "clave" [3 3 4 2 4])
part groove sound d time (get "clave")
part kick soind k time (get "clave")

I think the only question is where does the map that (def) writes to live?

... Well, I made a _super_ basic implementation. There's just an (atom {}) sitting there
amongst the parser, which (def) writes to and (get) reads from. In my initial attempt,
I didn't have luck with (def) from inside a part, but it works from init. It does
succeed at the basic task of allowing multiple parts to refer to the same data.
It's nice in that that data can be generated at startup, so I can have multiple parts
working on the same generated motive.
I found myself working with 3 voices playing off of the same melody, wanting to
be able to modulate transposition independtly of the cycles of the melody. As it is,
I can have
  +#(rand-int 0 5) (get "m")
which is okay, but it restricts the transposing to be in whole units of the melody.
I guess that's one more reason to work out multiple loops per aspect

***************************************************************************

ASPECT TIMES

So I've known for a long time that there should be an option for any aspect to have
its own rhythm determining when it advances to its next value. The basic case is pretty
clear in my mind:
  time 1 1 1.5 1.5
  sound 5 -2 3 8 1 7 0 0
  sound:time 4 3
...for example, would be the roots of the first section of ATTYA, in 7, with SSLL
as their rhythm.

That's basically how I envision it working.
What questions come to mind?
-Is there a problem with multi-aspects? If nnfn is calling a single iterator for the
multi-aspect, will it mess it up to have a sub-time for one of the aspects?
Would you have to refer to the multi-aspect as a whole? In practice, it's hard to
see why you'd group parts in a multi-aspect but want separate sub-times for each?
Maybe for now just not allow it? Another possibility would be to only allow a sub-time
for the multi-aspect as a whole. I think that's pretty reasonable, actually. The only
problem is maybe how to refer to the multi-aspect. "sound&volume:time" might be confusing
to look at. Maybe it's okay.
-What happens if the time aspect has a long break, and in the meantime another aspect's
sub-time has a lot of beats? What I worry about is that when you finally wanted a
note, the aspect with the busy sub-time would have to catch up, and potentially grind
through a lot of values. This could cause stuttering in playback.
One solution would be just to keep a bigger buffer time, in case that should happen. I'd
be sad to have to increase buffer time just for that reason, though.
Another would be to keep the sub-aspect moving along, even if it hasn't been called yet.
Actually, that could be a good enough way to do the whole thing. Have a function that
can return the proper value for an aspect, and that you also inform each time you
do a batch of notes, so it can update as much as it needs to, in order to be ready
to quickly return the proper value. That seems like as good a way as any to split
things up.

Otherwise, I think it's pretty clear. Instead of just an iterator, you also have the
option of a sub-timed iterator-like function. That thing itself uses an iterator for the sub-time
and one for the aspect in question.
The only difference from the interface's standpoint is you have to pass in the current
time-pos, which basic iterators don't need.

So I think the main things will be
-update the parser to include sub-time aspects & figure out how they'll look in the
 transformed tree.
-notice aspects with sub-times in make-iterators and create timed-iterators instead.
-in next-note-fns, either pass time-pos to all iterators, or detect which ones are
timed-iterators and pass it to those.
-write the actual timed-iterator fn.
-include in the timed-iterator the option to update to the current time-pos without
 returning a value, in order not to get too behind. Have this called by (update).

Oh, wow! Here's a dilemma: Normal aspects can be values or functions that are called
each time the loop gets to them. But timed aspects actually have 3 possibilities:
-simple value
-function that's called every single time you want a note
-function that's called once each time the sub-time loop gets around to it.
For example, in
  sound #(rand-int 0 12)
  sound:time 8
  time 1
should rand-int be called every 1 or every 8?
I'm pretty sure I'd like to have either option available. Wow!
Could I solve it with 2 layers of function?
#(#(rand-int 0 12)) or something?
##(rand-int 0 12)?
Maybe that's simple enough? I forget if the way things are currently set up relies
on nested de-thunking prior to final iterating, in which case this would be challenging.
So
  sound #(rand-int 0 12)
  sound:time 8 time 1
will return a number every 8, while
  sound #(#(rand-int 0 12))
  sound:time 8 time 1
will return a funciton every 8, which will then be dethunked?
I guess that'll have to work.
What about with cycles?
  sound 0 (cycle [1 2 3])
  sound:time 8
will return 0 for 8, 1 for 8, 0 for 8, 2 for 8
What if I want to spend 8 bars going through cycle A, then 8 going through cycle B?
  sound #(!(cycle [..A..])) #(!(cycle [..B..]))
Okay, I just tested that and it seems to work, although of course it's still not
guaranteed to work with aspect-times.
Wait, but what about nested functions?
  #(rand [#(repeatedly 6 #(rand-int 0 12)) [1 2 3]])
Do I want do fully dethunk, then take one value per time section? Or do I want to
generate a vector, and then iterate over that vector?
  (cycle [(cycle [1 2]) (cycle [(cycle [3 4]) (cycle [5 6])])])
What if I wanted to fully dethunk that?
What if I want to call it once and then get one of two cycles?
What if I what I mean is to get cycles of [1 2] [3 4] [1 2] [5 6]?
I think I need another function marker (probably ##) that tells the first iterator
to stop dethunking. Shoot, except that that works for functions where I'd be adding
a # anyway. I can change #(rand) to ##(rand), but (cycle) returns a function, so
so how do I tell the first iterator not to call cycle? Maybe I need to use a separate
symbol?
Maybe ^? ^#(rand), ^(cycle)... I guess that's as good as anything, for now. I can always
refactor that kind of thing, right?...
So I could have
  (cycle [(cycle [1 2]) (cycle [(cycle [3 4]) (cycle [5 6])])])
  (cycle [^(cycle [1 2]) ^(cycle [(cycle [3 4]) (cycle [5 6])])])
  (cycle [^(cycle [1 2]) (cycle [^(cycle [3 4]) ^(cycle [5 6])])])
  #(rand-int 0 12)
  ^#(rand-int 0 12)
Ugh... okay, I think that makes sense.
Quick check: does this fit with multi-aspects?
  time & sound  4 #(rand-int 0 12), 3 ^#(rand-int 0 12), 5 ^[1 2 3]
I think that's fine. The point is that everything within the expression a carot is
touching will be run through its own iterator for the duration of a time section.

Ooookaaaaayyyyy... Soooooo...
Once again, steps:

v-make parser recognize ^, (thus ^[], ^#(), ^!()).
v-make process-vec handle those cases, leaving intact those with ^.
v-make iterator checks for ^, leaves intact.
v-make parser includes sub-time aspects & figure out how they'll look in the
  transformed tree.
v-partition multi-aspects during make-iterators
v-notice aspects with sub-times in make-iterators and create timed-iterators instead.
v-in next-note-fns, either pass time-pos to all iterators, or detect which ones are
  timed-iterators and pass it to those.
v-write the actual timed-iterator fn. should return create an iterator for vecs.
 -include in the timed-iterator the option to update to the current time-pos without
  returning a value, in order not to get too behind. Have this called by (update).

...

Okay, I think I actually did it! Well, I know I got basic aspect-times working, and I know
I'm not completely done.
First of all, hooray!
Second, here's what needs to be done now:
-see if I need to keep timed-iterators somewhat up to date (now I'm thinking maybe I dont')
-figure out why ^#() isn't behaving properly.

...
Okay, fixed the ^#() problem. However, I hit on something else.
Suppose you had something like #(rand !(take 3 (shuffle (range 24)))), where 3 numbers
are chosen at the beginning and then randomly chosen between each time the function
is called, and you wanted the same thing, except that the 3 notes are resampled
each time you get to a new sub-time section. You'd need another gradation beyond !.
Currently you have ! to indicate that a subset of a function should be fully calculated
in advance. I wondered at some point if that would be enough, but couldn't think of
a case where it would be insufficient. Well, I think this is it.

Solutions?
-Bite the bullet and work out (let).
-Maybe employ degrees of !? Seems hacky, and I'd hate to see more than !!. !!!! would
 be weird.
