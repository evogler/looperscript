REFACTOR:
  -modules:
    -parser / transformer
    -vec-functions
    -tree-traverser
    -note-scheduler
    -looperscript ui stuff
    -Q: where to put event hook for live syntax / graphics?
  -vec-functions have proper parameters?
  -lazy-evaluation fully realized
  -pipeline for optional nodes
UPCOMING STEPS:
  -proper params. as well as bpm, setting for latency.
  -standardize mode concept. (e.g.'s: tuning, hz)
    -push/pop modes?
  -peek ahead at next note's time to properly calculate note durs re. time+
  -reparse input in background (which means encorporate core.async?)
  -parser versions
  -pause?
  -abstract node pipeline for playing notes
  -proper handling of bpm changes
LANGUAGE FEATURES:
  -try-repeatedly (try x times or until pred is matched (or score is maximized))
    -especially for use with coprime
  -legato/staccato!
  -sections defined within part, and then each aspect is defined per section
  -triggers (when time hits !, pitch moves)
  -parts with separate rhythm controlling steps
  -integrate nested rhythmic layers
  -chords (ala looper1's ",") (+ figure out logical questions)
  -arbitrary nos of multiple cycles to alter aspect (e.g. not just <p> and <tr>)
  -random but avoid what the note something else is currently playing
  -random for modes
  -specify filtering of multi-aspects for modes?
  -let
  -variables / quotes / aliasing (hopefully less hacky than {$a:} from looper
    -same definition for multiple parts with differences notated
    -dataflow / spreadsheetish approach?
  -chord changes?
    -chords? voice leading?
    -pitches as intervals of chords!!! (this could be a whole language!)
    -chords specified on lattice
  -logical operators (AND / OR 2 rhythms)
  -parts overlapping / covering eachother up (e.g. a fill interrupts a groove)
  -continuous-note mode
  -adsr
    -envelopes within aspect of single note
  -map any tuning system to integers (or possibly to non-integers as well!!)
  -express note as product of partials
  -gradual changes over time (e.g. ramps)
SECTION-LEVEL LANGUAGE IDEAS:
  -divide source file into
    -global param & configuration (default)
    -aspects (floating definitions of parts)
    -parts (already defined, set of aspects with defaults available)
    -section
      -groups of parts?
      -maybe sections is length plus each part and where to start in the part?
      -default program behavior is just go forever if sections aren't defined?
TECH STEPS:
  -functioning REPL!
  -mp3 caching!
  -lzma.js for GET
  -appache gzip .JS
  -check out more of web audio, especially LFO
  -iOS compatibility
  -explore limits of mobile webapp background consistency
  -user upload samples
  -reuse nodes when applicable?
  -webGL
  -Ace code editor!!!
INTERFACE:
  -tutorial mode!!!!!!
  -make console less of an eyesore
  -show current beat
  -daytime / nighttime mode
  -basic syntax highlighting (possibly via content-editable)
  -real-time syntax highlighting!!!
  -options panel?
  -keypress commands for things like mute
FURTHER STEPS:
  -real-time loop updates
  -user samples / more samples
  -step through loop by user input
  -tap tempo? tap tempo to indicate form of mp3?
  -play along with mp3?
  -'cursor' moving through loops, lazily evaluating?
  -(possibly separate noteon & noteoff for better performance during tempo changes?)
  -diff updates to text to require minimum recalculation
  -further synth controls
  -templating for interface
  -visual interfaces (esp. on/off grid)
  -big-button phone interfaces
  -graphical / animated representations of loops
  -MIDI and/or screen keyboard play-along (with intonation)
  -record playback to loop form (to capture randoms)
  -record to WAV/MP3
  -output to staff notation (maybe in browser, in real-time?)
  -split into more modular libraries, to use looper also with overtone
